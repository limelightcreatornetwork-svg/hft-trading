"""
Strategy Base Class

Defines the interface for all trading strategies.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, List, Any

from .thesis import Thesis

logger = logging.getLogger(__name__)


class SignalDirection(Enum):
    """Trading signal direction."""
    BUY_YES = "buy_yes"
    BUY_NO = "buy_no"
    SELL_YES = "sell_yes"
    SELL_NO = "sell_no"
    HOLD = "hold"


@dataclass
class Market:
    """Market data for strategy evaluation."""
    ticker: str
    title: str
    category: str
    
    # Pricing
    yes_price: int  # 1-99 cents
    no_price: int
    yes_volume: int
    no_volume: int
    open_interest: int
    
    # Orderbook
    best_bid: int
    best_ask: int
    bid_size: int
    ask_size: int
    spread: int
    
    # Timing
    open_time: datetime
    close_time: datetime
    time_to_close_hours: float
    
    # Status
    status: str
    
    # Metadata
    rules_text: Optional[str] = None
    series_ticker: Optional[str] = None
    
    @property
    def mid_price(self) -> float:
        return (self.best_bid + self.best_ask) / 2
    
    @property
    def spread_pct(self) -> float:
        if self.mid_price > 0:
            return self.spread / self.mid_price
        return 1.0
    
    @property
    def implied_prob(self) -> float:
        """Market-implied probability of YES."""
        return self.yes_price / 100
    
    @property
    def liquidity_score(self) -> float:
        """Simple liquidity score 0-1."""
        volume_score = min(self.yes_volume + self.no_volume, 10000) / 10000
        spread_score = max(0, 1 - self.spread_pct * 5)  # Penalize wide spreads
        return (volume_score + spread_score) / 2


@dataclass
class Signal:
    """Trading signal generated by strategy."""
    direction: SignalDirection
    market_ticker: str
    
    # Position sizing
    target_price: int  # Limit price
    target_count: int  # Number of contracts
    max_count: int     # Maximum contracts to buy
    
    # Signal quality
    confidence: float  # 0-1
    edge: float        # Expected edge after fees
    
    # Context
    strategy: str
    reason: str
    thesis_id: Optional[str] = None
    
    # Metadata
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def is_buy(self) -> bool:
        return self.direction in (SignalDirection.BUY_YES, SignalDirection.BUY_NO)
    
    @property
    def side(self) -> str:
        """Kalshi order side: 'yes' or 'no'."""
        if self.direction in (SignalDirection.BUY_YES, SignalDirection.SELL_YES):
            return "yes"
        return "no"
    
    @property
    def action(self) -> str:
        """Kalshi order action: 'buy' or 'sell'."""
        return "buy" if self.is_buy else "sell"


@dataclass
class StrategyContext:
    """Context passed to strategy for evaluation."""
    # Portfolio state
    account_balance: Decimal
    available_balance: Decimal
    positions: Dict[str, Dict]  # ticker -> position info
    open_orders: Dict[str, List[Dict]]  # ticker -> list of orders
    
    # Risk state
    daily_pnl: Decimal
    total_exposure: Decimal
    position_count: int
    
    # Limits
    max_position_per_market: Decimal
    max_order_size: Decimal
    max_total_exposure: Decimal
    
    # Flags
    kill_switch_active: bool
    circuit_breaker_state: str
    dry_run_mode: bool
    
    # Timing
    timestamp: datetime = field(default_factory=datetime.now)
    
    @property
    def can_trade(self) -> bool:
        return not self.kill_switch_active and self.circuit_breaker_state == "closed"
    
    def get_position(self, ticker: str) -> Optional[Dict]:
        """Get position for a market."""
        return self.positions.get(ticker)
    
    def has_position(self, ticker: str) -> bool:
        """Check if we have a position in market."""
        return ticker in self.positions


class Strategy(ABC):
    """
    Base class for all trading strategies.
    
    Implement this class to create a new trading strategy.
    The strategy will be called periodically with market data
    and should return a Signal if a trade is warranted.
    
    Example:
        class MyStrategy(Strategy):
            @property
            def name(self) -> str:
                return "my_strategy"
            
            @property
            def version(self) -> str:
                return "1.0.0"
            
            async def evaluate(self, market, thesis, context) -> Optional[Signal]:
                # Your strategy logic here
                if some_condition:
                    return Signal(...)
                return None
            
            def get_parameters(self) -> Dict:
                return {"param1": self.param1}
            
            def set_parameters(self, params: Dict):
                self.param1 = params.get("param1", self.param1)
    """
    
    def __init__(self):
        self._enabled = True
        self._evaluation_count = 0
        self._signal_count = 0
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Unique strategy identifier."""
        pass
    
    @property
    @abstractmethod
    def version(self) -> str:
        """Strategy version string."""
        pass
    
    @property
    def enabled(self) -> bool:
        """Whether strategy is enabled."""
        return self._enabled
    
    @enabled.setter
    def enabled(self, value: bool):
        self._enabled = value
    
    @abstractmethod
    async def evaluate(
        self,
        market: Market,
        thesis: Optional[Thesis],
        context: StrategyContext,
    ) -> Optional[Signal]:
        """
        Evaluate market and return trading signal if warranted.
        
        This is the main entry point for strategy logic.
        
        Args:
            market: Market data including price, volume, orderbook
            thesis: Existing thesis for this market (if any)
            context: Portfolio, risk, and execution context
        
        Returns:
            Signal with direction, size, and confidence, or None if no trade
        """
        pass
    
    @abstractmethod
    def get_parameters(self) -> Dict[str, Any]:
        """Return current strategy parameters."""
        pass
    
    @abstractmethod
    def set_parameters(self, params: Dict[str, Any]):
        """Update strategy parameters."""
        pass
    
    def should_invalidate_thesis(
        self,
        thesis: Thesis,
        market: Market,
        context: StrategyContext,
    ) -> Optional[str]:
        """
        Check if existing thesis should be invalidated.
        
        Override to implement thesis invalidation logic.
        
        Args:
            thesis: Active thesis to check
            market: Current market data
            context: Current context
        
        Returns:
            Invalidation reason string, or None if thesis still valid
        """
        return None
    
    def on_fill(self, market_ticker: str, count: int, price: int, thesis: Optional[Thesis]):
        """
        Called when an order from this strategy is filled.
        
        Override to implement fill handling logic.
        """
        pass
    
    def on_market_settle(self, market_ticker: str, outcome: bool, thesis: Optional[Thesis]):
        """
        Called when a market settles.
        
        Override to implement settlement handling.
        
        Args:
            market_ticker: The settled market
            outcome: True if YES won, False if NO won
            thesis: Thesis for this market (if any)
        """
        pass
    
    def get_stats(self) -> Dict[str, Any]:
        """Get strategy statistics."""
        return {
            "name": self.name,
            "version": self.version,
            "enabled": self.enabled,
            "evaluation_count": self._evaluation_count,
            "signal_count": self._signal_count,
            "signal_rate": (
                self._signal_count / self._evaluation_count
                if self._evaluation_count > 0 else 0
            ),
        }


class StrategyManager:
    """
    Manages multiple strategies and coordinates evaluation.
    
    Usage:
        manager = StrategyManager()
        manager.register(ValueStrategy())
        manager.register(EventDrivenStrategy())
        
        # Evaluate all strategies for a market
        signals = await manager.evaluate_market(market, context)
    """
    
    def __init__(self, thesis_tracker=None):
        self.strategies: Dict[str, Strategy] = {}
        self.thesis_tracker = thesis_tracker
    
    def register(self, strategy: Strategy):
        """Register a strategy."""
        self.strategies[strategy.name] = strategy
        logger.info(f"Registered strategy: {strategy.name} v{strategy.version}")
    
    def unregister(self, name: str):
        """Unregister a strategy."""
        if name in self.strategies:
            del self.strategies[name]
            logger.info(f"Unregistered strategy: {name}")
    
    def get_strategy(self, name: str) -> Optional[Strategy]:
        """Get strategy by name."""
        return self.strategies.get(name)
    
    def enable_strategy(self, name: str):
        """Enable a strategy."""
        strategy = self.strategies.get(name)
        if strategy:
            strategy.enabled = True
            logger.info(f"Enabled strategy: {name}")
    
    def disable_strategy(self, name: str):
        """Disable a strategy."""
        strategy = self.strategies.get(name)
        if strategy:
            strategy.enabled = False
            logger.info(f"Disabled strategy: {name}")
    
    async def evaluate_market(
        self,
        market: Market,
        context: StrategyContext,
    ) -> List[Signal]:
        """
        Evaluate all enabled strategies for a market.
        
        Returns list of signals from all strategies.
        """
        signals = []
        
        # Get thesis for this market
        thesis = None
        if self.thesis_tracker:
            active_theses = self.thesis_tracker.get_active_theses(market.ticker)
            thesis = active_theses[0] if active_theses else None
        
        for strategy in self.strategies.values():
            if not strategy.enabled:
                continue
            
            try:
                strategy._evaluation_count += 1
                
                # Check for thesis invalidation
                if thesis:
                    invalidation = strategy.should_invalidate_thesis(thesis, market, context)
                    if invalidation:
                        if self.thesis_tracker:
                            self.thesis_tracker.invalidate_thesis(thesis.id, invalidation)
                        thesis = None  # Clear invalidated thesis
                
                # Evaluate strategy
                signal = await strategy.evaluate(market, thesis, context)
                
                if signal:
                    strategy._signal_count += 1
                    signals.append(signal)
                    logger.info(
                        f"Strategy {strategy.name} generated signal for {market.ticker}: "
                        f"{signal.direction.value} @ {signal.target_price}"
                    )
            
            except Exception as e:
                logger.error(f"Error evaluating strategy {strategy.name}: {e}", exc_info=True)
        
        return signals
    
    def get_all_stats(self) -> Dict[str, Any]:
        """Get stats for all strategies."""
        return {
            name: strategy.get_stats()
            for name, strategy in self.strategies.items()
        }
